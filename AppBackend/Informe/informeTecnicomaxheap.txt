-------------------------------------------------------------------------------
1. Descripción general
----------------------
El MaxHeap se utiliza para gestionar una cola de prioridad de usuarios, donde cada usuario tiene una prioridad asociada (según su perfil).  
Permite insertar usuarios, extraer el de mayor prioridad, actualizar prioridades y consultar el top 5, todo en tiempo eficiente.

-------------------------------------------------------------------------------
2. Estructura de datos
----------------------
- Un **array dinámico** de estructuras `Elemento`.
- Cada `Elemento` contiene:
    - dni: identificador único del usuario.
    - prioridad: valor numérico (mayor valor = mayor prioridad).
    - ts: timestamp de encolado.
- Variables de control:
    - capacidad: tamaño máximo actual del array.
    - tamanio: número de elementos en el heap.

-------------------------------------------------------------------------------
3. Inicialización (Constructor)
-------------------------------
El constructor reserva memoria para el array dinámico de elementos, con una capacidad inicial (por defecto 100).  
El heap comienza vacío (`tamanio = 0`).

**Pseudocódigo:**
```
heap = new Elemento[capacidad]
tamanio = 0
```

-------------------------------------------------------------------------------
4. Propiedad de MaxHeap
-----------------------

El MaxHeap se implementa como un array binario, donde para cada posición `i`:
- El padre está en la posición `(i - 1) / 2`
- El hijo izquierdo en `2 * i + 1`
- El hijo derecho en `2 * i + 2`

Pseudocódigo:
```
int padre(int i) { return (i - 1) / 2; }
int izq(int i)   { return 2 * i + 1; }
int der(int i)   { return 2 * i + 2; }
```
**Explicación:**  
Estas funciones permiten navegar eficientemente el heap representado como array, accediendo a padres e hijos de cualquier nodo en O(1).

-------------------------------------------------------------------------------
heapifyDown(int i)
------------------
Pseudocódigo:
```
heapifyDown(i):
    mientras i tiene al menos un hijo:
        mayor = i
        si izq(i) < tamanio y heap[izq(i)].prioridad > heap[mayor].prioridad:
            mayor = izq(i)
        si der(i) < tamanio y heap[der(i)].prioridad > heap[mayor].prioridad:
            mayor = der(i)
        si mayor != i:
            intercambiar heap[i] y heap[mayor]
            i = mayor
        sino:
            salir
```
**Explicación:**  
Reordena el heap desde la posición `i` hacia abajo, intercambiando con el hijo de mayor prioridad si es necesario, hasta restaurar la propiedad de MaxHeap.

-------------------------------------------------------------------------------
heapifyUp(int i)
----------------
Pseudocódigo:
```
Algoritmo heapifyUp(i):
    mientras i > 0 y heap[i].prioridad > heap[padre(i)].prioridad:
        intercambiar heap[i] y heap[padre(i)]
        i = padre(i)
```
**Explicación:**  
Reordena el heap desde la posición `i` hacia arriba, subiendo el elemento si su prioridad es mayor que la de su padre, hasta restaurar la propiedad de MaxHeap.

-------------------------------------------------------------------------------
expandir()
----------
Pseudocódigo:
```
Algoritmo expandir():
    nuevaCap = capacidad * 2
    nuevo = new Elemento[nuevaCap]
    para i = 0 hasta tamanio-1:
        nuevo[i] = heap[i]
    eliminar heap
    heap = nuevo
    capacidad = nuevaCap
```
**Explicación:**  
Duplica la capacidad del array cuando está lleno, copiando todos los elementos al nuevo array. Esto permite que el heap crezca dinámicamente sin perder eficiencia.

-------------------------------------------------------------------------------
5. Métodos principales y pseudocódigo
-------------------------------------

**5.1 insertar(dni, perfil, ts)**
Agrega un nuevo usuario al heap, asignando prioridad según el perfil.  
Si el array está lleno, lo expande al doble de capacidad.

Pseudocódigo:
```
Algoritmo Insertar(dni, perfil, ts):
    si tamanio == capacidad:
        expandir()
    e = Elemento(dni, perfilAPrioridad(perfil), ts)
    heap[tamanio] = e
    heapifyUp(tamanio)
    tamanio += 1
```
**Explicación:**  
- Crea un nuevo `Elemento` con el DNI, prioridad del perfil y timestamp.
- **Complejidad:** O(log n) por heapifyUp.


**5.2 extraerMax()**
Extrae y retorna el usuario con mayor prioridad (raíz del heap).

Pseudocódigo:
```
Algoritmo ExtraerMax():
    si tamanio == 0:
        retornar nulo
    root = heap[0]
    heap[0] = heap[tamanio-1]
    tamanio -= 1
    heapifyDown(0)
    retornar root
```
**Explicación:**  
- Intercambia la raíz con el último elemento, reduce el tamaño y reordena el heap.
- Si el heap está vacío, retorna `nulo`.

- **Complejidad:** O(log n) por heapifyDown.

**5.3 actualizarPrioridad(idx, nuevaPrio)**
Actualiza la prioridad de un elemento y reordena el heap.

Pseudocódigo:
```
Algoritmo ActualizarPrioridad(idx, nuevaPrio):
    antigua = heap[idx].prioridad
    heap[idx].prioridad = nuevaPrio
    si nuevaPrio > antigua:
        heapifyUp(idx)
    sino:
        heapifyDown(idx)
```
**Explicación:**  
- Si la nueva prioridad es mayor, sube el elemento; si es menor, lo baja.
- Esto mantiene la propiedad de MaxHeap tras una actualización.
- **Complejidad:** O(log n).

**5.4 verTop5(outCount)**
Devuelve los 5 elementos de mayor prioridad sin modificar el heap original.

Pseudocódigo:
```
Algoritmo VerTop5():
    copia = copiar heap[0..tamanio-1]
    para i = 0 hasta min(5, tamanio)-1:
        maxIdx = i
        para j = i+1 hasta tamanio-1:
            si copia[j].prioridad > copia[maxIdx].prioridad:
                maxIdx = j
        intercambiar copia[i] y copia[maxIdx]
    retornar copia[0..min(5, tamanio)-1]
```
**Explicación:**  
- Crea una copia del heap y ordena los 5 elementos de mayor prioridad.
- **Complejidad:** O(5n) ≈ O(n).


**5.5 buscarIndice(dni)**
Busca la posición de un usuario por su DNI.

Pseudocódigo:
```
Algoritmo BuscarIndice(dni):
    para i = 0 hasta tamanio-1:
        si heap[i].dni == dni:
            retornar i
    retornar -1
```
**Explicación:**  
- Recorre el heap buscando el DNI.
- **Complejidad:** O(n).

-------------------------------------------------------------------------------
6. Endpoints y uso
--------------------------
El MaxHeap se expone a través de una API REST para su uso en aplicaciones.  
A continuación se presentan los endpoints implementados en el backend y su relación con las operaciones del MaxHeap:

- **POST /cola**
  - Descripción: Inserta un usuario en la cola de prioridad (heap).
  - Cuerpo: `{ "dni": 12345678, "ts": 1625257200 }`
  - Uso interno: Llama a `heap.insertar(dni, perfil, ts)`.

- **GET /cola/top5**
  - Descripción: Obtiene los 5 usuarios con mayor prioridad.
  - Respuesta: `[ { "dni": ..., "perfil": ..., "prioridad": ..., "ts": ... }, ... ]`
  - Uso interno: Llama a `heap.verTop5()`.

- **POST /cola/extract**
  - Descripción: Extrae el usuario con mayor prioridad y lo marca como atendido.
  - Respuesta: `{ "dni": ..., "ts": ..., "prioridad": ... }`
  - Uso interno: Llama a `heap.extraerMax()`.

- **PUT /cola/update**
  - Descripción: Actualiza la prioridad de un usuario en la cola.
  - Cuerpo: `{ "dni": ..., "nuevo_perfil": "nuevoPerfil" }`
  - Uso interno: Llama a `heap.buscarIndice(dni)` y `heap.actualizarPrioridad(idx, nuevaPrio)`.

- **GET /usuarios**
  - Descripción: Lista usuarios no atendidos ni en cola (consulta combinada con hash).

Estos endpoints permiten interactuar con el MaxHeap de manera eficiente, aprovechando sus operaciones de inserción, extracción, consulta top y actualización de prioridades.

-------------------------------------------------------------------------------
7. Análisis de complejidad
--------------------------

| Operación           | Tiempo Promedio | Peor Caso | Espacio    |
|---------------------|-----------------|-----------|------------|
| insertar            | O(log n)        | O(log n)  | O(n)       |
| extraerMax          | O(log n)        | O(log n)  | O(n)       |
| actualizarPrioridad | O(log n)        | O(log n)  | O(1)       |
| verTop5             | O(n)            | O(n)      | O(n)       |
| buscarIndice        | O(n)            | O(n)      | O(1)       |
| heapifyDown         | O(log n)        | O(log n)  | O(1)       |
| heapifyUp           | O(log n)        | O(log n)  | O(1)       |
| expandir            | O(n)            | O(n)      | O(n)       |

**Espacio total:** O(n)  
**Expansión:** Cuando el array se llena, se duplica la capacidad (O(n) en ese momento, amortizado O(1) por inserción).

> *Conclusión:* MaxHeap permite gestionar una cola de prioridad eficiente para usuarios, con inserción y extracción en tiempo logarítmico y consultas top en tiempo lineal.

-------------------------------------------------------------------------------
