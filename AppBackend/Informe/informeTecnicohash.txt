-------------------------------------------------------------------------------
1. Descripción general
----------------------
La tabla hash se utiliza para almacenar y acceder rápidamente a los usuarios por su clave.
Permite operaciones de inserción, búsqueda y validación en tiempo promedio O(1).
La función hash es modular y se realiza rehashing cuando la carga supera el umbral configurado.

-------------------------------------------------------------------------------
2. Estructura de datos
----------------------
- Un **arreglo (array) de punteros**, donde cada posición se denomina "bucket".
- Cada bucket apunta al **inicio de una lista enlazada** de nodos.
- Cada nodo contiene los datos del elemento y un puntero al siguiente nodo de la lista.

-------------------------------------------------------------------------------
3. Inicialización (Constructor)
-------------------------------
Al crear una instancia de la clase `TablaHash`, el constructor reserva memoria para el arreglo de punteros (buckets), de tamaño inicial configurable (por defecto 17).
Cada posición del arreglo se inicializa en `nullptr`, indicando que todos los buckets están vacíos al principio.

**Pseudocódigo:**
```
tabla = new NodoHash*[tam];
para i = 0 hasta tam-1:
    tabla[i] = nullptr
```

**Resumen visual:**
```
[bucket 0] -> nullptr
[bucket 1] -> nullptr
...
[bucket 16] -> nullptr
```

-------------------------------------------------------------------------------
3.3 Función hashFunc: núcleo del hash
-------------------------------------
La función `int TablaHash::hashFunc(long clave) const` es el núcleo de la tabla hash, ya que determina en qué bucket se almacenará cada elemento.

**Código:**
```
int TablaHash::hashFunc(long clave) const
{
    long h = clave < 0 ? -clave : clave;
    return static_cast<int>(h % tam);
}
```

**Explicación:**
- Convierte la clave a positiva si es negativa, para evitar índices negativos.
- Calcula el módulo de la clave con el tamaño de la tabla (`tam`), obteniendo así un índice válido entre 0 y tam-1.
- Usa `static_cast<int>` para asegurar que el resultado sea del tipo correcto para indexar el array de buckets.
- Este índice determina el bucket donde se insertará o buscará el elemento.

**Importancia:**
- Una buena función hash distribuye uniformemente los elementos entre los buckets, minimizando colisiones y asegurando eficiencia O(1) promedio en inserciones y búsquedas.
- En este caso, la función es simple y eficiente para claves numéricas como el DNI.

-------------------------------------------------------------------------------
4. Encadenamiento separado (Separate Chaining)
---------------------------------------------
Cada bucket sirve como cabeza de una lista enlazada.
Si varios elementos generan el mismo índice por hash, se insertan al frente de la lista, resolviendo colisiones sin afectar otros buckets.

-------------------------------------------------------------------------------
5. Manejo de colisiones
-----------------------
Cuando ocurre una colisión:
- Se crea un nuevo `NodoHash` con la clave y perfil.
- Se enlaza al inicio de la lista del bucket correspondiente.
- El bucket funciona como una pila: el elemento más reciente queda al principio.

-------------------------------------------------------------------------------
6. Métodos principales y pseudocódigo
-------------------------------------

**6.1 insertar(dni, perfil)**
Este método agrega un nuevo elemento a la tabla hash.
Primero, verifica si la carga de la tabla supera el umbral configurado (`cargaMaxima`). Si es así, realiza rehashing para aumentar el tamaño de la tabla.
Luego, calcula el índice del bucket usando la función hash (`hashFunc(clave)`) y crea un nuevo nodo (`NodoHash`).
El nuevo nodo se inserta al inicio de la lista enlazada del bucket correspondiente.

Pseudocódigo:
Algoritmo InsertarElemento(clave, valor)
    Si (usados + 1) / tam > cargaMaxima entonces
        rehash()
    idx ← hashFunc(clave)
    nuevo ← NodoHash(clave, valor)
    nuevo.siguiente ← tabla[idx]
    tabla[idx] ← nuevo
    usados ← usados + 1

**Explicación:**
- Si la tabla está llena, se duplica su tamaño y se reubican los elementos (**Rehashing**: O(n) al superarse carga, amortizado O(1)).
- La inserción al inicio de la lista enlazada asegura que sea rápida (**Inserción**: O(1) promedio).


**6.2 buscar(dni)**
Este método busca un elemento en la tabla hash utilizando su clave.
Primero, calcula el índice del bucket usando la función hash (`hashFunc(clave)`).
Luego, recorre la lista enlazada del bucket correspondiente hasta encontrar el nodo con la clave buscada o llegar al final.

Pseudocódigo:
Algoritmo BuscarElemento(clave)
    idx ← hashFunc(clave)
    actual ← tabla[idx]
    mientras actual ≠ nulo hacer
        si actual.clave = clave entonces
            retornar actual
        actual ← actual.siguiente
    retornar nulo

**Explicación:**
- La búsqueda recorre la lista enlazada del bucket calculado.
- Si encuentra el nodo con la clave buscada, lo retorna; si no, retorna `nulo`. (**O(1) promedio, O(n) peor caso**).



**6.3 validar(dni)**
Este método verifica si un elemento existe en la tabla hash.
Internamente, utiliza el método `buscar(clave)` y retorna `verdadero` si el resultado es distinto de `nulo`.

Pseudocódigo:
Algoritmo ValidarElemento(clave)
    si BuscarElemento(clave) ≠ nulo entonces
        retornar verdadero
    retornar falso

**Explicación:**
- Es una operación de búsqueda simplificada que solo devuelve un valor booleano.
- Útil para evitar duplicados antes de insertar un nuevo elemento. (**O(1) promedio**).

**6.4 rehash()**
Este método duplica el tamaño de la tabla hash y reinserta todos los elementos en la nueva tabla.
Primero, crea un nuevo arreglo de buckets con el doble de tamaño más uno (`tam * 2 + 1`).
Luego, recorre todos los buckets de la tabla antigua y reinserta cada nodo en la nueva tabla utilizando el método `insertar`.

Pseudocódigo:
Algoritmo RehashTablaHash()
    nuevoTam ← tam * 2 + 1
    vieja ← tabla
    tabla ← nuevo arreglo de tamaño nuevoTam
    para i ← 0 hasta nuevoTam - 1 hacer
        tabla[i] ← nulo
    viejoTam ← tam
    tam ← nuevoTam
    usados ← 0
    para i ← 0 hasta viejoTam - 1 hacer
        actual ← vieja[i]
        mientras actual ≠ nulo hacer
            insertar(actual.clave, actual.valor)
            siguiente ← actual.siguiente
            eliminar actual
            actual ← siguiente
    eliminar vieja

**Explicación:**
- Duplica el tamaño de la tabla para reducir colisiones y mejorar la eficiencia.
- Reubica todos los elementos en los nuevos buckets utilizando la función hash actualizada. (**Coste**: O(n + m), donde m = buckets).

**6.5 marcarEnCola(dni, estado) / marcarAtendido(dni, estado)**
- Llaman a `Buscar(dni)` (O(1) promedio) y actualizan un bool.
Pseudocódigo:
```Algoritmo MarcarEnCola(dni, estado)
    n ← Buscar(dni)
    si n ≠ nulo entonces
        n.estado ← estado 

Algoritmo MarcarAtendido(dni, estado)
    n ← Buscar(dni)
    si n ≠ nulo entonces
        n.estado ← estado
```
**Explicación:**
- `marcarEnCola` y `marcarAtendido` actualizan el estado de un usuario específico.
- Utilizan la búsqueda para encontrar el nodo y luego actualizan su estado. (**O(1) promedio**).


**6.6 incrementar(clave) / obtenerConteo(clave)**
- Utilizan `buscarPorPerfil`, recorriendo todos los buckets y sus listas: O(n + m).
Pseudocódigo:
```Algoritmo IncrementarConteo(clave)
    n ← Buscar(clave)
    si n ≠ nulo entonces
        n.conteo ← n.conteo + 1

Algoritmo ObtenerConteo(clave)
    n ← Buscar(clave)
    si n ≠ nulo entonces
        retornar n.conteo
    retornar 0

**Explicación:**
- `incrementar` incrementa el contador de un perfil específico.
- `obtenerConteo` retorna el contador asociado a un perfil, o 0 si no existe.

-------------------------------------------------------------------------------
6. Endpoints y uso
--------------------------
El Hash se expone a través de una API REST para su uso en aplicaciones.  
A continuación se presentan los endpoints implementados en el backend y su relación con las operaciones del Hash:

- **POST /usuario**
  - Descripción: Inserta un nuevo usuario en la tabla hash.
  - Cuerpo: `{ "dni": 12345678, "perfil": "perfil1" }`
  - Uso interno: Llama a `usuarios.insertar(dni, perfil)`.

- **GET /usuario/{dni}**
  - Descripción: Obtiene la información de un usuario por su DNI.
  - Respuesta: `{ "valid": true/false, "perfil": ... }`
  - Uso interno: Llama a `usuarios.buscar(dni)`.

- **PUT /usuario/{dni}**
  - Descripción: Actualiza el perfil de un usuario existente.
  - Cuerpo: `{ "perfil": "nuevoPerfil" }`
  - Uso interno: Llama a `usuarios.buscar(dni)` y actualiza el perfil.

- **GET /usuarios**
  - Descripción: Lista usuarios no atendidos ni en cola.
  - Uso interno: Itera sobre todos los buckets usando `usuarios.getBucket(i)`.

- **marcarEnCola / marcarAtendido**
  - Se usan internamente en endpoints de la cola para actualizar el estado del usuario.

Estos endpoints permiten interactuar con la tabla hash de manera eficiente, aprovechando sus operaciones de inserción, búsqueda, actualización y consulta de estado.

-------------------------------------------------------------------------------
7. Análisis de complejidad
--------------------------

**Parámetros:**
- n = número de elementos (usuarios).
- m = número de buckets.
- λ = n/m (factor de carga, 0.7).
-------------------------------------------------------------------------------

| Operación                       | Tiempo Promedio | Peor Caso    | Espacio       |
|---------------------------------|-----------------|--------------|---------------|
| hashFunc                        | O(1)            | O(1)         | O(1)          |
| insertar                        | O(1) amortizado | O(n)         | O(1)          |
| buscar / validar                | O(1)            | O(n)         | O(1)          |
| marcarEnCola / marcarAtendido   | O(1)            | O(n)         | O(1)          |
| rehash                          | —               | O(n + m)     | O(n + m)      |
| incrementar / obtenerConteo     | O(n + m)        | O(n + m)     | O(1)          |



> *Conclusión:* operaciones CRUD de usuarios en ***O(1) promedio***, con coste espacial lineal y picos controlados por rehashing.  
> La función hashFunc es fundamental y garantiza acceso a buckets en tiempo constante.

Con este análisis, queda claramente demostrado que TablaHash ofrece operaciones promedio constantes (O(1)) para inserción y búsqueda, con un coste espacial lineal y picos de O(n + m) controlados.