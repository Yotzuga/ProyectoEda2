----------------------------------------------------------------------------
1. Problemas con la INTERFAZ GR√ÅFICA en aplicaci√≥n de escritorio
----------------------------------------------------------------------------
Durante la fase inicial se intent√≥ implementar la interfaz gr√°fica como una aplicaci√≥n de escritorio en C++ utilizando Code::Blocks como entorno de desarrollo. Sin embargo, surgieron m√∫ltiples dificultades:

‚ö†Ô∏è Dependencias complejas: Librer√≠as gr√°ficas como wxWidgets, Qt o GTK requieren configuraci√≥n avanzada de compiladores y enlazadores (linkers).

‚ö†Ô∏è Compatibilidad limitada: Estas librer√≠as no siempre son portables entre Windows, Linux y macOS sin ajustes espec√≠ficos.

‚ö†Ô∏è Curva de aprendizaje alta: Frameworks gr√°ficos en C++ implican tiempos de aprendizaje elevados.

üìå Impacto: Se ralentiz√≥ el desarrollo y la UI no cumpl√≠a con los est√°ndares de dise√±o modernos.

‚úÖ Soluci√≥n adoptada:
Se migr√≥ la interfaz a una aplicaci√≥n web moderna usando Vite + React:

Desarrollo √°gil gracias a la modularidad de React.

Compatibilidad inmediata en cualquier sistema operativo (acceso v√≠a navegador).

Integraci√≥n sencilla de estilos con TailwindCSS o Material UI.

Eliminaci√≥n de problemas de compilaci√≥n cruzada.

----------------------------------------------------------------------------
2. Problemas al conectar Backend con Frontend
----------------------------------------------------------------------------
Al integrar el backend en C++ (con estructuras de datos optimizadas) y el frontend web, surgieron estos problemas:

‚ùå CORS bloqueado por navegadores: El frontend React no pod√≠a consumir la API del backend por pol√≠tica de seguridad.

‚ùå Falta de soporte HTTP nativo en C++: No existe un middleware como Express (Node.js) o Flask (Python).

‚ùå Formato de datos: Se necesitaba un formato est√°ndar (JSON) para intercambiar datos entre ambos.

üìå Impacto: El frontend no lograba comunicarse con el backend.

‚úÖ Soluci√≥n adoptada:

Se implement√≥ un servidor REST en C++ usando cpp-httplib.

Se a√±adieron cabeceras CORS al backend:

pgsql
Copiar
Editar
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT, OPTIONS
Access-Control-Allow-Headers: Content-Type
Se integr√≥ nlohmann/json para manejar JSON de forma eficiente.

Se dej√≥ abierta la posibilidad de migrar a Crow para proyectos m√°s grandes.

----------------------------------------------------------------------------
3. Problemas de rendimiento y soluciones (AVL, Heap, Hash)
----------------------------------------------------------------------------
üìå Problemas detectados:
üî• Altas colisiones en HashTable con datos masivos (m√°s de 10k usuarios).

üî• Heap lento al expandir memoria din√°mica (duplicaci√≥n de arrays grandes).

üî• AVL Tree con inserciones desbalanceadas cuando los timestamps eran muy cercanos.

‚úÖ Soluciones t√©cnicas:
HashTable:

Se implement√≥ Rehashing din√°mico con carga m√°xima 0.7 para mantener O(1) en inserciones y b√∫squedas.

Encadenamiento separado (listas enlazadas) para resolver colisiones.

MaxHeap:

Uso de expandir() al llegar a la capacidad m√°xima, duplicando tama√±o con costo amortizado O(1).

heapifyUp y heapifyDown optimizados para mantener la propiedad de MaxHeap.

AVL Tree:

Rotaciones simples y dobles (rotarIzquierda, rotarDerecha) para mantener balanceo en O(log n).

Inserciones con timestamps distribuidos para evitar skew.

----------------------------------------------------------------------------
4. Conclusi√≥n t√©cnica
----------------------------------------------------------------------------
La arquitectura final combina:
‚úÖ HashTable: acceso r√°pido O(1) promedio para usuarios.
‚úÖ MaxHeap: manejo eficiente de la cola de prioridad (inserci√≥n/extracci√≥n O(log n)).
‚úÖ AVL Tree: consultas por rango y zona con tiempos O(log n).
‚úÖ Frontend React: interfaz moderna, responsiva y multiplataforma.
‚úÖ Backend C++ REST API: eficiente y ligero gracias a cpp-httplib y nlohmann/json.

üîë Resultado: Sistema r√°pido, escalable y con una integraci√≥n backend-frontend robusta.