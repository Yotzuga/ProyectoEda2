-------------------------------------------------------------------------------
1. Descripción general
----------------------
El árbol AVL se utiliza para registrar y consultar accesos a zonas por timestamp, manteniendo los datos siempre balanceados para garantizar eficiencia.  
Permite insertar accesos, consultar rangos de tiempo y determinar la zona con más entradas, todo en tiempo logarítmico.

-------------------------------------------------------------------------------
2. Estructura de datos
----------------------
- NodoAVL:
    - zona: nombre de la zona de acceso.
    - timestamp: momento del acceso. ts ->  100010100202 ->  01/07/2024 00:00:00.
    - altura: altura del nodo en el árbol.
    - factor_balance: diferencia de alturas entre subárbol izquierdo y derecho.
    - izquierdo, derecho, padre: punteros a hijos y padre.

- ArbolAVL:
    - raiz: puntero al nodo raíz del árbol.

-------------------------------------------------------------------------------
3. Inicialización (Constructor)
-------------------------------
El constructor inicializa el árbol vacío (`raiz = nullptr`).

Pseudocódigo NodoAVL:
constructor(zona, timestamp) {
    this.zona = zona
    this.timestamp = timestamp
    this.altura = 1
    this.factor_balance = 0
    this.izquierdo = null
    this.derecho = null
    this.padre = null
}

Pseudocódigo ArbolAVL:
constructor() {
    raiz = null
}
-------------------------------------------------------------------------------
4. Propiedades del AVL
----------------------
- Es un árbol binario de búsqueda auto-balanceado.
- Para cada nodo, la diferencia de alturas entre subárbol izquierdo y derecho es como máximo 1.
- Tras cada inserción, se actualizan los factores de balance y se realizan rotaciones si es necesario.

-------------------------------------------------------------------------------
NodoAVL* insertarRecursivo(NodoAVL* nodo, const std::string& zona, long ts);
----------------------
Pseudocódigo:
Algoritmo insertarRecursivo(nodo, zona, ts):
    si nodo == nullptr:
        retornar nuevo NodoAVL(zona, ts)
    si ts < nodo.timestamp:
        nodo.izquierdo = insertarRecursivo(nodo.izquierdo, zona, ts)
        nodo.izquierdo.padre = nodo
    sino:
        nodo.derecho = insertarRecursivo(nodo.derecho, zona, ts)
        nodo.derecho.padre = nodo
    actualizarFactor(nodo)
    retornar reBalancear(nodo)

**Complejidad:** O(log n) promedio, O(n) peor caso (árbol degenerado).
**Explicación:**  
La inserción en un árbol AVL es logarítmica en promedio gracias al balanceo automático. 
Si el árbol se desbalancea, se realizan rotaciones para restaurar el equilibrio.

-------------------------------------------------------------------------------
void actualizarFactor(NodoAVL* nodo);
----------------------
Pseudocódigo:
Algoritmo actualizarFactor(nodo):
    h_izq = (nodo.izquierdo != null) ? nodo.izquierdo.altura : 0
    h_der = (nodo.derecho != null) ? nodo.derecho.altura : 0
    nodo.altura = 1 + max(h_izq, h_der)
    nodo.factor_balance = h_izq - h_der


**Complejidad:** O(1) si se almacena la altura, O(n) si se recalcula desde cero.
**Explicación:**  
Actualiza el factor de balance de un nodo, que es la diferencia de alturas entre sus subárboles izquierdo y derecho. 
Es fundamental para decidir si se necesita rebalancear.

-------------------------------------------------------------------------------
NodoAVL* reBalancear(NodoAVL* nodo);
----------------------
Pseudocódigo:
Algoritmo reBalancear(nodo):
    actualizarFactor(nodo)
    si nodo.factor_balance > 1:
        si nodo.izquierdo.factor_balance < 0:
            nodo.izquierdo = rotarIzquierda(nodo.izquierdo)
        retornar rotarDerecha(nodo)
    si nodo.factor_balance < -1:
        si nodo.derecho.factor_balance > 0:
            nodo.derecho = rotarDerecha(nodo.derecho)
        retornar rotarIzquierda(nodo)
    retornar nodo

**Complejidad:** O(1) por rebalanceo individual, O(log n) total por inserción.
**Explicación:**  
Restaura el balance del árbol tras una inserción o eliminación. Puede requerir una o dos rotaciones para mantener la propiedad AVL.

-------------------------------------------------------------------------------
NodoAVL* rotarIzquierda(NodoAVL* nodo);
----------------------
Pseudocódigo:
Algoritmo rotarIzquierda(nodo):
    r = nodo.derecho
    nodo.derecho = r.izquierdo
    si r.izquierdo:
        r.izquierdo.padre = nodo
    r.izquierdo = nodo
    r.padre = nodo.padre
    nodo.padre = r
    actualizarFactor(nodo)
    actualizarFactor(r)
    retornar r

**Complejidad:** O(1)
**Explicación:**  
Realiza una rotación simple a la izquierda para reducir la altura del subárbol derecho y restaurar el balance.

-------------------------------------------------------------------------------
NodoAVL* rotarDerecha(NodoAVL* nodo);
----------------------
Pseudocódigo:
Algoritmo rotarDerecha(nodo):
    l = nodo.izquierdo
    nodo.izquierdo = l.derecho
    si l.derecho:
        l.derecho.padre = nodo
    l.derecho = nodo
    l.padre = nodo.padre
    nodo.padre = l
    actualizarFactor(nodo)
    actualizarFactor(l)
    retornar l

**Complejidad:** O(1)
**Explicación:**  
Realiza una rotación simple a la derecha para reducir la altura del subárbol izquierdo y restaurar el balance.

-------------------------------------------------------------------------------
5. Métodos principales y pseudocódigo
-------------------------------------

**5.1 insertar(zona, timestamp)**
Inserta un nuevo acceso en el árbol, manteniendo el balance.

Pseudocódigo:
Algoritmo Insertar(zona, ts):
    raiz = insertarRecursivo(raiz, zona, ts)

Algoritmo insertarRecursivo(nodo, zona, ts):
    si nodo == nullptr:
        retornar nuevo NodoAVL(zona, ts)
    si ts < nodo.timestamp:
        nodo.izquierdo = insertarRecursivo(nodo.izquierdo, zona, ts)
        nodo.izquierdo.padre = nodo
    sino:
        nodo.derecho = insertarRecursivo(nodo.derecho, zona, ts)
        nodo.derecho.padre = nodo
    actualizarFactor(nodo)
    retornar reBalancear(nodo)

- **Complejidad:** O(log n) promedio.
- **Explicación:**
La inserción en un árbol AVL es logarítmica en promedio gracias al balanceo automático.
Si el árbol se desbalancea, se realizan rotaciones para restaurar el equilibrio.

**5.2 rangoTiempos(inicio, fin)**
Devuelve los accesos cuyo timestamp está en el rango dado.

Pseudocódigo:
Algoritmo rangoTiempos(inicio, fin):
    out = []
    rangoRec(raiz, inicio, fin, out)
    retornar out

- **Complejidad:** O(k + log n), donde k es el número de resultados.
- **Explicación:** La búsqueda de rangos en un árbol AVL se beneficia de su estructura balanceada, 
    permitiendo un acceso eficiente a los nodos en el rango especificado.

**5.3 Algoritmo rangoRec(nodo, inicio, fin, out):**
Pseudocódigo:
Algoritmo rangoRec(nodo, inicio, fin, out):
    si nodo == nullptr:
        retornar
    si nodo.timestamp > inicio:
        rangoRec(nodo.izquierdo, inicio, fin, out)
    si nodo.timestamp >= inicio y nodo.timestamp <= fin:
        out.agregar(nodo)
    si nodo.timestamp < fin:
        rangoRec(nodo.derecho, inicio, fin, out)

- **Complejidad:** O(k + log n), donde k es el número de resultados.
- **Explicación:** La búsqueda de rangos en un árbol AVL se beneficia de su estructura balanceada, 
    permitiendo un acceso eficiente a los nodos en el rango especificado.   

**5.4 zonaMasEntradas()**
Devuelve la zona con más accesos, usando una tabla hash auxiliar para el conteo.
Pseudocódigo:
Algoritmo zonaMasEntradas():
    cnt = nueva TablaHash
    contarZonas(raiz, cnt)
    best = ""
    maxc = 0
    para cada bucket en cnt:
        para cada nodo en bucket:
            si nodo.contador > maxc:
                maxc = nodo.contador
                best = nodo.perfil
    retornar best

- **Complejidad:** O(n) para recorrer todo el árbol.
- **Explicación:** La búsqueda de la zona con más accesos implica contar los accesos en cada zona,
    lo que requiere recorrer todo el árbol.

**5.5 Algoritmo contarZonas(nodo, cnt):**
Pseudocódigo:
Algoritmo contarZonas(nodo, cnt):
    si nodo == nullptr:
        retornar
    cnt.incrementar(nodo.zona)
    contarZonas(nodo.izquierdo, cnt)
    contarZonas(nodo.derecho, cnt)

- **Complejidad:** O(n) para recorrer todo el árbol.
- **Explicación:** La búsqueda de la zona con más accesos implica contar los accesos en cada zona,
    lo que requiere recorrer todo el árbol.

-------------------------------------------------------------------------------
6. Endpoints y uso
--------------------------
El árbol AVL se expone a través de una API REST para su uso en aplicaciones.  
A continuación se presentan los endpoints implementados en el backend y su relación con las operaciones del AVL:

- **POST /acceso**
  - Descripción: Inserta un acceso a una zona con timestamp.
  - Cuerpo: `{ "zona": "puerta-vip", "ts": 1720406400 }`
  - Uso interno: Llama a `arbol.insertar(zona, ts)`.

- **GET /accesos/rango?inicio=...&fin=...**
  - Descripción: Devuelve los accesos cuyo timestamp está en el rango dado.
  - Respuesta: `[ { "zona": ..., "ts": ... }, ... ]`
  - Uso interno: Llama a `arbol.rangoTiempos(inicio, fin)`.

- **GET /accesos/zona_top**
  - Descripción: Devuelve la zona con más accesos.
  - Respuesta: `"puerta-vip"`
  - Uso interno: Llama a `arbol.zonaMasEntradas()`.

Estos endpoints permiten interactuar con el árbol AVL de manera eficiente, aprovechando sus operaciones de inserción, consulta por rango y consulta de zona más concurrida.

-------------------------------------------------------------------------------
7. Análisis de complejidad
--------------------------
**Notas:**
- n = número total de nodos/accesos almacenados en el árbol AVL.
- k = número de resultados devueltos en una consulta de rango (por ejemplo, cantidad de accesos en el intervalo [inicio, fin]).
- Las operaciones de recorrido completo (mostrar, zonaMasEntradas, contarZonas) son O(n) porque visitan todos los nodos.
- Las operaciones de inserción, heapify y rebalanceo son O(log n) gracias al balanceo automático del AVL.
- El espacio total es O(n), ya que cada acceso se almacena en un nodo.

| Operación           | Tiempo Promedio | Peor Caso | Espacio    |
|---------------------|-----------------|-----------|------------|
| insertar            | O(log n)        | O(log n)  | O(n)       |
| rangoTiempos        | O(k + log n)    | O(n)      | O(k)       |
| zonaMasEntradas     | O(n)            | O(n)      | O(n)       |
| mostrar             | O(n)            | O(n)      | O(n)       |
| contarZonas         | O(n)            | O(n)      | O(n)       |
| rangoRec            | O(k + log n)    | O(n)      | O(k)       |
| buscarIndice        | O(n)            | O(n)      | O(1)       |
| heapifyDown         | O(log n)        | O(log n)  | O(1)       |
| heapifyUp           | O(log n)        | O(log n)  | O(1)       |
| expandir            | O(n)            | O(n)      | O(n)       |
-------------------------------------------------------------------------------

> *Conclusión:* El árbol AVL permite registrar y consultar accesos por tiempo y zona de forma eficiente, 
garantizando operaciones logarítmicas y balance automático incluso con grandes volúmenes de datos.
